#!/usr/bin/env python3
"""Generate a makefile for Mbed Crypto or Mbed TLS.
"""

import argparse
import glob
import itertools
import os
import re
import shutil
import subprocess
import sys
import tempfile

def sjoin(*args):
    return ' '.join(args)

def append_to_value(d, key, *values):
    lst = d.setdefault(key, [])
    lst += values

class EnvironmentOption:
    def __init__(self, var, default='', help=None,
                 option=None):
        self.var = var
        self.option = ('--' + var.lower().replace('_', '-')
                       if option is None else option)
        self.default = default
        self.help = help

_environment_options = [
    EnvironmentOption('AR', 'ar',
                      'Archive building tool'),
    EnvironmentOption('ARFLAGS', '-src',
                      'Options to pass to ${AR} (e.g. "rcs"),'),
    EnvironmentOption('CC', 'cc',
                      'C compiler'),
    EnvironmentOption('CFLAGS', '-Os',
                      'Options to always pass to ${CC} when compiling'),
    EnvironmentOption('LDFLAGS', '',
                      'Options to always pass to ${CC} when linking'),
    EnvironmentOption('PERL', 'perl',
                      'Perl interpreter'),
    EnvironmentOption('PYTHON', 'python3',
                      'Python3 interpreter'),
    EnvironmentOption('RM', 'rm -f',
                      'Program to remove files (e.g. "rm -f"),'),
    EnvironmentOption('WARNING_CFLAGS', '-Wall -Wextra -Werror',
                      'Options to always pass to ${CC}'),
]

_submodule_names = ['crypto']

class ClassicTestGenerator:
    def __init__(self, options):
        self.options = options

    def target(self, c_file):
        return c_file

    dependencies = [
        '$(SOURCE_DIR)/tests/scripts/generate_code.pl',
        '$(SOURCE_DIR)/tests/suites/helpers.function',
        '$(SOURCE_DIR)/tests/suites/main_test.function'
    ]

    def command(self, function_file, data_file):
        return sjoin('$(PERL)',
                     '$(SOURCE_DIR_FROM_TESTS)/tests/scripts/generate_code.pl',
                     '$(SOURCE_DIR_FROM_TESTS)',
                     os.path.splitext(function_file)[0],
                     os.path.splitext(data_file)[0])

class OnTargetTestGenerator:
    def __init__(self, options):
        self.options = options

    def target(self, c_file):
        datax_file = os.path.splitext(c_file)[0] + '.datax'
        return sjoin(c_file, datax_file)

    #FIXME: not right for crypto tests in submodule
    dependencies = [
        '$(SOURCE_DIR)/tests/scripts/generate_test_code.py',
        '$(SOURCE_DIR)/tests/suites/helpers.function',
        '$(SOURCE_DIR)/tests/suites/main_test.function'
    ]

    def command(self, function_file, data_file):
        #FIXME: not right for crypto tests in submodule
        return sjoin('$(PYTHON) $(SOURCE_DIR_FROM_TESTS)/tests/scripts/generate_test_code.py',
                     '-f $(SOURCE_DIR_FROM_TESTS)/' + function_file,
                     '-d $(SOURCE_DIR_FROM_TESTS)/' + data_file,
                     '-t $(SOURCE_DIR_FROM_TESTS)/tests/suites/main_test.function',
                     '-p $(SOURCE_DIR_FROM_TESTS)/tests/suites/host_test.function',
                     '--helpers-file $(SOURCE_DIR_FROM_TESTS)/tests/suites/helpers.function',
                     '-s $(SOURCE_DIR_FROM_TESTS)/tests/suites',
                     '-o .')

class MakefileMaker:
    def __init__(self, options, source_path):
        self.options = options
        if self.options.indirect_extensions:
            self.executable_extension = '$(EXEXT)'
            self.library_extension = '$(LIBEXT)'
            self.object_extension = '$(OBJEXT)'
            self.shared_library_extension = '$(DLEXT)'
        else:
            self.executable_extension = self.options.executable_extension
            self.library_extension = self.options.library_extension
            self.object_extension = self.options.object_extension
            self.shared_library_extension = self.options.shared_library_extension
        self.source_path = source_path
        self.out = None
        self.libraries = None
        self.help = {'help': 'Show this help.'}
        self.clean = []
        self.dependency_cache = {}
        self.submodules = [submodule for submodule in _submodule_names
                           if self.source_exists(submodule)]
        if self.source_exists('tests/scripts/generate_test_code.py'):
            self.test_generator = OnTargetTestGenerator(options)
        else:
            self.test_generator = ClassicTestGenerator(options)
        # Unset fields that are only meaningful at certain later times.
        # Setting them here makes Pylint happy, but having set them here
        # makes it harder to diagnose if some method is buggy and attempts
        # to use a field whose value isn't actually known.
        del self.libraries # Set when generating the library targets
        del self.out # Set only while writing the output file

    def get_file_submodule(self, filename):
        for submodule in self.submodules:
            if filename.startswith(submodule + os.sep):
                return submodule, filename[len(submodule) + 1:]
        return None, filename

    def crypto_file_path(self, filename):
        in_crypto = os.path.join('crypto', filename)
        if os.path.exists(in_crypto):
            filename = in_crypto
        return '$(SOURCE_DIR)/' + filename

    def source_exists(self, filename):
        return os.path.exists(os.path.join(self.options.source, filename))

    def list_submodule_files(self, start, sub_start, pattern, all_sources):
        sub_sources = [src[start:] for src in glob.glob(pattern)]
        for sub_src in sub_sources:
            # Remove submodule and extension
            base = os.path.splitext(sub_src[sub_start:])[0]
            # Skip generated files that may be present in the source tree.
            if base.endswith('_generated'):
                continue
            # Skip files that were seen in an earlier submodule.
            if base not in all_sources:
                all_sources[base] = sub_src

    def list_source_files(self, directory, pattern):
        # Files in earlier submodules shadow files in later ones.
        start = len(self.options.source) + 1
        all_sources = {}
        for submodule in self.submodules:
            sub_start = len(submodule) + 1
            sub_pattern = os.path.join(self.options.source, submodule,
                                       directory, pattern)
            self.list_submodule_files(start, sub_start, sub_pattern,
                                      all_sources)
        root_pattern = os.path.join(self.options.source, directory, pattern)
        self.list_submodule_files(start, 0, root_pattern,
                                  all_sources)
        return all_sources

    def line(self, text):
        self.out.write(text + '\n')

    def words(self, *words):
        self.line(' '.join(words))

    def assign(self, name, *value_words):
        nonempty_words = [word for word in value_words if word]
        self.line(' '.join([name, '='] + nonempty_words))

    def format(self, template, *args):
        self.line(template.format(*args))

    def comment(self, template, *args):
        self.format('## ' + template, *args)

    def add_dependencies(self, name, *dependencies):
        for dep in dependencies:
            self.format('{}: {}', name, dep)

    def add_existing_dependencies(self, name, *dependencies):
        for dep in dependencies:
            if os.path.exists(os.path.join(self.options.source, dep)):
                self.format('{}: $(SOURCE_DIR)/{}', name, dep)

    def target(self, name, dependencies, commands,
               help=None, phony=False, short=None):
        self.add_dependencies(name, *dependencies)
        if not dependencies:
            self.format('{}:', name)
        if short is not None:
            self.format('\t@$(ECHO_IF_QUIET) "  {}"', short)
        for com in commands:
            self.format('\t{}{}',
                        ('' if short is None else '$(Q)'),
                        com.replace('\n', ' \\\n\t'))
        if help is not None:
            self.help[name] = help
        if phony:
            self.format('.PHONY: {}', name)

    def environment_option_subsection(self):
        self.comment('Tool settings')
        for envopt in _environment_options:
            if envopt.help is not None:
                self.comment('{}', envopt.help)
            self.assign(envopt.var,
                        getattr(self.options, envopt.var.lower()))

    def settings_section(self):
        self.comment('Path settings')
        self.assign('SOURCE_DIR', self.source_path)
        self.assign('SOURCE_DIR_FROM_TESTS', '../$(SOURCE_DIR)')
        self.line('')
        self.environment_option_subsection()
        self.line('')
        self.comment('Configuration')
        if self.options.indirect_extensions:
            self.line('DLEXT = ' + self.options.shared_library_extension)
            self.line('LIBEXT = ' + self.options.library_extension)
            self.line('OBJEXT = ' + self.options.object_extension)
            self.line('EXEXT =' + self.options.executable_extension)
        self.line('')
        self.comment('Internal variables')
        self.line('AUX_ECHO_IF_QUIET_ = :')
        self.line('AUX_Q_ =')
        self.line('AUX_ECHO_IF_QUIET_$(V) = echo')
        self.line('AUX_Q_$(V) = @')
        self.line('ECHO_IF_QUIET = $(AUX_ECHO_IF_QUIET_)')
        self.line('Q = $(AUX_Q_)')

    def include_path(self, filename):
        dirs = []
        submodule, base = self.get_file_submodule(filename)
        subdirs = ['include', 'include/mbedtls', 'library']
        if base.startswith('tests'):
            subdirs.append('tests')
        for subdir in subdirs:
            if submodule is None:
                dirs += [os.path.join(submodule, subdir)
                         for submodule in self.submodules]
            dirs.append(subdir)
            if submodule is not None:
                dirs.append(os.path.join(submodule, subdir))
        return dirs

    def include_path_options(self, filename):
        return ' '.join(['-I $(SOURCE_DIR)/' + dir
                         for dir in self.include_path(filename)])

    def collect_c_dependencies(self, c_file, stack=frozenset()):
        if c_file in self.dependency_cache:
            return self.dependency_cache[c_file]
        if c_file in stack:
            return set()
        include_path = ([os.path.dirname(c_file)] + self.include_path(c_file))
        dependencies = set()
        extra = set()
        with open(os.path.join(self.options.source, c_file)) as stream:
            for line in stream:
                m = re.match(r'#include "(.*)"', line)
                if m is None:
                    continue
                filename = m.group(1)
                for subdir in include_path:
                    if os.path.exists(os.path.join(self.options.source,
                                                   subdir, filename)):
                        dependencies.add('/'.join([subdir, filename]))
                        break
                else:
                    if filename.endswith('.c'):
                        extra.add(os.path.dirname(c_file) + '/' + filename)
        for dep in dependencies:
            dependencies |= self.collect_c_dependencies(dep, stack | {dep})
        dependencies |= extra
        self.dependency_cache[c_file] = dependencies
        return dependencies

    def c_with_dependencies(self, c_file):
        deps = self.collect_c_dependencies(c_file)
        return [(self.get_file_submodule(filename)[1]
                 if '_generated.' in filename else
                 '$(SOURCE_DIR)/' + filename)
                for filename in sorted(deps) + [c_file]]

    def c_dependencies_only(self, c_files):
        deps = set.union(*[self.collect_c_dependencies(c_file)
                           for c_file in c_files])
        return ['$(SOURCE_DIR)/' + filename for filename in sorted(deps)]

    _potential_libraries = ['crypto', 'x509', 'tls']
    @staticmethod
    def library_of(module):
        module = os.path.basename(module)
        if module.startswith('x509') or \
           module in ['certs', 'pkcs11']:
            return 'x509'
        elif module.startswith('ssl') or \
             module in ['debug', 'net', 'net_sockets']:
            return 'tls'
        else:
            return 'crypto'

    def library_section(self):
        self.comment('Library targets')
        self.assign('LIBRARY_CFLAGS',
                    '-I include/mbedtls', # must come first, for "config.h"
                    '-I include',
                    self.include_path_options('library/*'))
        # Enumerate modules and emit the rules to build them
        modules = self.list_source_files('library', '*.c')
        for module in sorted(modules.keys()):
            o_file = module + self.object_extension
            c_file = '$(SOURCE_DIR)/' + modules[module]
            self.target(o_file, self.c_with_dependencies(modules[module]),
                        [sjoin('$(CC)',
                                '$(WARNING_CFLAGS)',
                               '$(CFLAGS)',
                               '$(LIBRARY_CFLAGS)',
                               '-o $@',
                               '-c', c_file)],
                        short=('CC    ' + c_file))
        contents = {}
        # Enumerate libraries and the rules to build them
        for lib in self._potential_libraries:
            contents[lib] = []
        for module in sorted(modules.keys()):
            contents[self.library_of(module)].append(module)
        libraries = [lib for lib in self._potential_libraries
                     if contents[lib]]
        for lib in libraries:
            self.format('libmbed{}_modules = {}', lib, ' '.join(contents[lib]))
            self.format('libmbed{}_objects = $(libmbed{}_modules:={})',
                        lib, lib, self.object_extension)
            self.target('library/libmbed{}{}'.format(lib, self.library_extension),
                        ['$(libmbed{}_objects)'.format(lib)],
                        ['$(AR) $(ARFLAGS) $@ $(libmbed{}_objects)'.format(lib)],
                        short='AR    $@')
        self.libraries = ['library/libmbed{}{}'.format(lib, self.library_extension)
                          for lib in libraries]
        self.target('lib', self.libraries,
                    [],
                    help='Build the static libraries.',
                    phony=True)
        self.clean.append(sjoin(*['library/*' + ext
                                  for ext in (self.library_extension,
                                              self.object_extension,
                                              self.shared_library_extension)]))

    @staticmethod
    def dash_l_lib(lib):
        base = os.path.splitext(os.path.basename(lib))[0]
        if base.startswith('lib'):
            base = base[3:]
        if not base.startswith('mbed'):
            base = 'mbed' + base
        return '-l' + base

    _auxiliary_objects = {
        'programs/ssl/ssl_client2': ['programs/ssl/query_config'],
        'programs/ssl/ssl_server2': ['programs/ssl/query_config'],
        'programs/test/query_compile_time_config': [
            'programs/ssl/query_config', # in Mbed TLS
            'programs/test/query_config', # in Mbed Crypto
        ],
    }
    _auxiliary_sources = set([obj
                              for _main, objs in _auxiliary_objects.items()
                              for obj in objs])

    def program_uses_lib(self, app, lib):
        basename = os.path.basename(app)
        subdir = os.path.basename(os.path.dirname(app))
        if lib == 'crypto':
            return True
        elif lib == 'x509':
            return (subdir in ['ssl', 'x509'] or
                    (subdir == 'test' and basename == 'selftest' and
                     self.source_exists('library/x509.c')))
        elif lib == 'tls':
            return (subdir == 'ssl' or
                    (subdir == 'x509' and basename == 'cert_app') or
                    basename.endswith('_client') or
                    basename.endswith('_server') or
                    basename.endswith('_proxy'))

    def program_subsection(self, base, source_file, executables):
        object_file = base + self.object_extension
        source_path = '$(SOURCE_DIR)/' + source_file
        if os.path.basename(base) == 'psa_constant_names':
            script_path = self.crypto_file_path('scripts/generate_psa_constants.py')
            self.target(base + '_generated.c',
                        ([script_path] +
                         [self.crypto_file_path(
                             os.path.join('include', 'psa', filename)
                          )
                          for filename in ['crypto_extra.h',
                                           'crypto_values.h']]),
                        [script_path],
                        short='Gen   $@')
        self.target(object_file, self.c_with_dependencies(source_file),
                    [sjoin('$(CC)',
                           '$(WARNING_CFLAGS)',
                           '$(CFLAGS)',
                           '$(PROGRAMS_CFLAGS)',
                           '-I', os.path.dirname(base), # for generated files
                           '-c', source_path,
                           '-o $@')],
                    short='CC    $@')
        if base in self._auxiliary_sources:
            return
        exe_file = base + self.executable_extension
        object_deps = [dep + self.object_extension
                       for dep in self._auxiliary_objects.get(base, [])
                       if self.source_exists(dep + '.c')]
        libs = [lib for lib in reversed(self._potential_libraries)
                if self.program_uses_lib(base, lib)]
        lib_files = ['library/libmbed{}{}'.format(lib, self.library_extension)
                     for lib in libs]
        dash_l_libs = [self.dash_l_lib(lib) for lib in libs]
        self.target(exe_file, [object_file] + object_deps + lib_files,
                    [sjoin('$(CC)',
                           object_file,
                           sjoin(*object_deps),
                           '$(LDFLAGS)',
                           '$(PROGRAMS_LDFLAGS)',
                           sjoin(*dash_l_libs),
                           '-o $@')],
                    short='LD    $@')
        executables.append(exe_file)

    def programs_section(self):
        self.comment('Sample programs')
        self.assign('PROGRAMS_CFLAGS',
                    '-I include',
                    self.include_path_options('programs/*/*'))
        self.assign('PROGRAMS_LDFLAGS',
                    '-L library')
        programs = self.list_source_files('', 'programs/*/*.c')
        executables = []
        for base in sorted(programs.keys()):
            self.program_subsection(base, programs[base], executables)
        dirs = itertools.groupby(sorted(programs.values()), os.path.dirname)
        for subdir, _ in dirs:
            self.target(subdir + '/seedfile', ['tests/seedfile'],
                        ['cp tests/seedfile $@'])
        self.assign('programs', *executables)
        self.target('programs', ['$(programs)'],
                    [],
                    help='Build the sample programs.',
                    phony=True)
        self.clean.append('programs/*/*{} $(programs)'
                          .format(self.object_extension))
        # TODO: *_demo.sh

    def test_generator_rule(self, function_file, data_file, c_file, exe_file):
        cmd = self.test_generator.command(function_file, data_file)
        self.target(self.test_generator.target(c_file),
                    ['$(SOURCE_DIR)/' + function_file,
                     '$(SOURCE_DIR)/' + data_file,
                     '$(test_host_generate_deps)'],
                    ['cd tests && ' + cmd],
                    short='Gen   $@')

    def test_subsection(self, base, data_file, executables):
        try:
            function_base = base[:base.index('.')]
        except ValueError:
            function_base = base
        function_file = os.path.join(os.path.dirname(data_file),
                                     function_base + '.function')
        c_file = os.path.join('tests', base + '.c')
        exe_file = os.path.join('tests', base + self.executable_extension)
        self.test_generator_rule(function_file, data_file, c_file, exe_file)
        self.target(exe_file,
                    (self.c_dependencies_only([function_file]) +
                     ['$(lib)', '$(test_host_build_deps)', c_file]),
                    [sjoin('$(CC)',
                           '$(WARNING_CFLAGS)',
                           '$(CFLAGS)',
                           '$(TESTS_CFLAGS)',
                           c_file,
                           '$(LDFLAGS)',
                           '$(TESTS_LDFLAGS)',
                           '$(test_libs)',
                           '-o $@')],
                    short='CC    $@')
        executables.append(exe_file)
        self.target(base + '.run', [exe_file, 'tests/seedfile'],
                    ['cd tests && ./' + os.path.basename(exe_file)],
                    phony=True)

    def tests_section(self):
        self.comment('Test targets')
        self.assign('TESTS_CFLAGS',
                    '-Wno-unused-function',
                    '-I include',
                    self.include_path_options('tests/*'))
        self.assign('TESTS_LDFLAGS',
                    '-L library')
        self.assign('test_libs',
                    *[self.dash_l_lib(lib) for lib in reversed(self.libraries)])
        self.assign('test_common_generate_deps',
                    *self.test_generator.dependencies)
        # FIXME: grab the function files from the submodule
        self.assign('test_host_generate_deps',
                    '$(test_common_generate_deps)',
                    '$(SOURCE_DIR)/tests/suites/host_test.function')
        self.assign('test_target_generate_deps',
                    '$(test_common_generate_deps)',
                    '$(SOURCE_DIR)/tests/suites/target_test.function')
        host_build_deps = self.c_dependencies_only(
            [filename for filename in [
                'tests/suites/helpers.function',
                'tests/suites/main_test.function'
            ] if self.source_exists(filename)])
        self.assign('test_host_build_deps', *host_build_deps)
        data_files = self.list_source_files('tests/suites', '*.data')
        executables = []
        for base in sorted(data_files.keys()):
            self.test_subsection(os.path.basename(base),
                                 data_files[base],
                                 executables)
        self.assign('test_apps', *executables)
        self.target('tests', ['$(test_apps)'],
                    [],
                    help='Build the host tests.',
                    phony=True)
        self.target('tests/seedfile', [],
                    ['dd bs=64 count=1 </dev/urandom >$@'])
        self.target('check', ['$(test_apps)', 'tests/seedfile'],
                    ['cd tests && $(PERL) scripts/run-test-suites.pl --skip=$(SKIP_TEST_SUITES)'],
                    help='Run all the test suites.',
                    phony=True)
        self.clean.append('tests/*.c tests/*.datax $(test_apps)')
        # TODO: test_psa_constant_names.py

    def help_lines(self):
        return ['{} - {}'.format(name, self.help[name])
                for name in sorted(self.help.keys())]

    def output_all(self):
        self.comment('Generated by {}', ' '.join(sys.argv))
        self.comment('Do not edit this file! All modifications will be lost.')
        self.line('')
        self.settings_section()
        self.line('')
        self.target('default', ['all'], [], phony=True)
        self.line('')
        self.target('all', ['lib', 'programs', 'tests'], [], phony=True)
        self.line('')
        self.target('pwd', [], ['pwd'], phony=True, short='PWD') # for testing
        self.line('')
        self.library_section()
        self.line('')
        self.programs_section()
        self.line('')
        self.tests_section()
        self.line('')
        self.target('clean', [],
                    ['$(RM) ' + patterns for patterns in self.clean],
                    help='Remove all generated files.',
                    short='RM    {generated files}',
                    phony=True)
        self.line('')
        self.target('help', [],
                    ['@echo "{}"'.format(line) for line in self.help_lines()],
                    phony=True)
        self.line('')
        self.comment('End of generated file.')

    def generate(self):
        destination = os.path.join(self.options.dir, 'Makefile')
        temp_file = destination + '.new'
        with open(temp_file, 'w') as out:
            try:
                self.out = out
                self.output_all()
            finally:
                del self.out
        os.replace(temp_file, destination)

class ConfigMaker:
    def __init__(self, options):
        self.options = options
        self.source_file = options.config_file
        if self.source_file is None:
            self.source_file = os.path.join(options.source,
                                            'include', 'mbedtls', 'config.h')
            self.source_file_path = 'source/include/mbedtls/config.h'
        else:
            self.source_file_path = os.path.abspath(source_file)
        self.target_file = os.path.join(options.dir,
                                        'include', 'mbedtls', 'config.h')

    def start(self):
        raise NotImplementedError

    def set(self, name, value):
        raise Exception("Configuration method {} does not support setting options"
                        .format(options.config_mode))

    def unset(self, name):
        raise Exception("Configuration method {} does not support unsetting options"
                        .format(options.config_mode))

    def batch(self, name):
        raise Exception("Configuration method {} does not support batch-setting options"
                        .format(options.config_mode))

    def finish(self):
        raise NotImplementedError

    def run(self):
        self.start()
        if self.options.config_name is not None:
            self.batch(self.options.config_name)
        for spec in self.options.config_unset:
            for name in re.split(r'[\t ,]+', spec):
                self.unset(name)
        for spec in self.options.config_set:
            m = re.match(r'(?P<name>[0-9A-Z_a-z]+)' +
                         r'(?P<args>\([\t ,0-9A-Z_a-z]*\))?' +
                         r'(?P<sep>[=,]?)', spec)
            if m is None or \
               (m.group('args') is not None and m.group('sep') == ',') :
                raise Exception("Invalid argument to --config-set")
            if m.group('sep') == ',':
                for name in spec.split(','):
                    self.set(name)
            else:
                name = spec[:m.start('sep')]
                value = spec[m.end('sep'):]
                self.set(name, value)
        self.finish()
_config_classes = {}

class ConfigCopy(ConfigMaker):
    def start(self):
        shutil.copyfile(self.source_file, self.target_file)

    def run_config_script(self, *args):
        subprocess.check_call(['perl', 'scripts/config.pl'] + list(args),
                              cwd=self.options.dir)

    def set(self, name, value):
        if value is None:
            self.run_config_script('set', name)
        else:
            self.run_config_script('set', name, value)

    def unset(self, name):
        self.run_config_script('unset', name)

    def batch(self, name):
        self.run_config_script(name)

    def finish(self):
        pass
_config_classes['copy'] = ConfigCopy

class ConfigInclude(ConfigMaker):
    def __init__(self, *args):
        super().__init__(*args)
        self.lines = []

    def start(self):
        source_path = self.source_file_path
        if not os.path.isabs(source_path):
            source_path = os.path.join(os.pardir, os.pardir, source_path)
        self.lines.append('#ifndef MBEDTLS_CHECK_CONFIG_H')
        self.lines.append('#include "{}"'.format(source_path))
        self.lines.append('')

    def set(self, name, value):
        if value is None:
            self.lines.append('#define ' + name)
        else:
            self.lines.append('#define ' + name + ' ' + value)

    def unset(self, name):
        self.lines.append('#undef ' + name)

    def finish(self):
        self.lines.append('')
        self.lines.append('#undef MBEDTLS_CHECK_CONFIG_H')
        self.lines.append('#include "mbedtls/check_config.h"')
        self.lines.append('#endif')
        with open(self.target_file, 'w') as out:
            for line in self.lines:
                out.write(line + '\n')
_config_classes['include'] = ConfigInclude

class BuildTreeMaker:
    def __init__(self, options):
        self.options = options
        self.source_path = os.path.abspath(options.source)
        self.makefile = MakefileMaker(options, 'source')
        if options.config_mode is None:
            if options.config_name is None:
                options.config_mode = 'include'
            else:
                options.config_mode = 'copy'
        self.config = _config_classes[options.config_mode](options)

    def programs_subdirs(self):
        tops = ([self.options.source] +
                [os.path.join(self.options.source, submodule)
                 for submodule in _submodule_names])
        return [os.path.basename(d)
                for top in tops
                for d in glob.glob(os.path.join(top, 'programs', '*'))
                if os.path.isdir(d)]

    def make_subdir(self, subdir):
        path = os.path.join(self.options.dir, *subdir)
        if not os.path.exists(path):
            os.makedirs(path)

    def make_link(self, sub_link, link):
        link_path = os.path.join(self.options.dir, *link)
        if not os.path.exists(link_path):
            os.symlink(os.path.join(*([os.pardir] * (len(link) - 1) +
                                      ['source'] + sub_link)),
                       link_path)

    def make_link_maybe(self, link):
        for submodule in [''] + _submodule_names:
            sub_link = [submodule] + link
            if os.path.exists(os.path.join(self.options.source, *sub_link)):
                self.make_link(sub_link, link)

    def run(self):
        for subdir in ([['include', 'mbedtls'],
                        ['library'],
                        ['tests']] +
                       [['programs', d] for d in self.programs_subdirs()]):
            self.make_subdir(subdir)
        source_link = os.path.join(self.options.dir, 'source')
        if not os.path.samefile(self.options.source, self.options.dir) and \
           not os.path.exists(source_link):
            os.symlink(self.source_path, source_link)
        for link in [['include', 'psa'], # hack for psa_constant_names.py
                     ['scripts'],
                     ['tests', 'compat.sh'],
                     ['tests', 'data_files'],
                     ['tests', 'scripts'],
                     ['tests', 'ssl-opt.sh']]:
            self.make_link_maybe(link)
        self.makefile.generate()
        self.config.run()

def arg_type_bool(arg):
    if not isinstance(arg, str):
        return arg
    arg = arg.lower()
    if arg in ['1', 't', 'true', 'y', 'yes']:
        return True
    elif arg in ['0', 'f', 'false', 'n', 'no']:
        return False
    else:
        raise argparse.ArgumentTypeError('invalid boolean value: ' + repr(arg))

def main():
    parser = argparse.ArgumentParser(description=__doc__)
    for envopt in _environment_options:
        parser.add_argument(envopt.option,
                            default=envopt.default,
                            help='{} ({})'.format(envopt.help, envopt.var))
    parser.add_argument('--config-file',
                        help='Base config.h to use')
    parser.add_argument('--config-mode',
                        choices=_config_classes.keys(),
                        help='What to do with config.h')
    parser.add_argument('--config-name',
                        help='Configuration to set with scripts/config.pl')
    parser.add_argument('--config-set',
                        action='append', default=[],
                        help='Additional symbol to set in config.h')
    parser.add_argument('--config-unset',
                        action='append', default=[],
                        help='Symbol to unset in config.h')
    parser.add_argument('--dir', '-d',
                        default=os.curdir,
                        help='Build directory to create')
    parser.add_argument('--executable-extension',
                        default='',
                        help='File extension for executables')
    parser.add_argument('--indirect-extensions',
                        type=arg_type_bool, default=False,
                        help='Whether to use makefile variable for file extensions')
    parser.add_argument('--library-extension',
                        default='.a',
                        help='File extension for static libraries')
    parser.add_argument('--object-extension',
                        help='File extension for object files',
                        default='.o')
    parser.add_argument('--shared-library-extension',
                        help='File extension for shared libraries',
                        default='.so')
    parser.add_argument('--source', '-s',
                        help='Root directory of the source tree',
                        default=os.curdir)
    options = parser.parse_args()
    builder = BuildTreeMaker(options)
    builder.run()

if __name__ == '__main__':
    main()
